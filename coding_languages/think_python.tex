\documentclass{article}
\usepackage[margin=0.5in]{geometry}
\setlength{\parindent}{0em}
\setlength{\parskip}{0.5em}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{amsmath}
\usepackage{mdwlist}
\usepackage{color}
\usepackage{xcolor}
\usepackage{verbatim}

\usepackage{titlesec}
\titleformat*{\section}{\LARGE\bfseries}
\titleformat*{\subsection}{\Large\bfseries}
\titleformat*{\subsubsection}{\large\bfseries}

\definecolor{sectioncolor}{rgb}{0.8, 0.0, 0.0}
\definecolor{subsectioncolor}{rgb}{0.41,0.16,0.38}
\definecolor{subsubsectioncolor}{rgb}{0.45, 0.31, 0.59}
\definecolor{ver}{HTML}{004400}

\makeatletter
  % Make all 'verbatim' text a different color!
  \renewcommand\verbatim@font{\normalfont\ttfamily\color{ver}}
  % Up single quote
  \let \@sverbatim \@verbatim
  \def \@verbatim {\@sverbatim \verbatimplus}
  {\catcode`'=13 \gdef \verbatimplus{\catcode`'=13 \chardef '=13 }}
\makeatother

\usepackage{sectsty}
\sectionfont{\color{sectioncolor}}
\subsectionfont{\color{subsectioncolor}}
\subsubsectionfont{\color{subsubsectioncolor}}
\definecolor{darkpowderblue}{rgb}{0.0, 0.2, 0.6}

\setlist{itemsep=-1ex,}
\setlist[description]{%
    %itemsep=-1ex,
    align=right, labelsep=1em,
    leftmargin=*,
    labelindent=3cm,
    }
\renewcommand{\descriptionlabel}[1]{\ttfamily{#1}}

\usepackage{hyperref}
\hypersetup{colorlinks=true,urlcolor=darkpowderblue,linkcolor=black}
\urlstyle{same}

\title{Think Python (and other useful things)}
\author{Allen B. Downey (and Laurel Farris)}
\date{\today}

%------------------------------------------------------------------------------%
\begin{document}
\maketitle
\url{http://www.greenteapress.com/thinkpython/html/index.html}
%---------------------------------------------------------------------------%
\tableofcontents\newpage

% Chapter 1
\section{The way of the program}

The single most important skill for a computer scientist is
{\bf problem solving}.
Problem solving means the ability to formulate problems,
think creatively about solutions, and express a solution clearly and
accurately. As it turns out, the process of learning to program is an
excellent opportunity to practice problem-solving skills.

\ldots

% Chapter 2
\section{Variables, expressions, and statements}
\subsection{Values and types}
If you are not sure what type a value has, the interpreter can tell
you:
\begin{verbatim}
>>> type('Hello, World!')
<type `str'>
>>> type(17)
<type `int'>
>>> type(3.2)
<type `float'>
\end{verbatim}
\subsection{Variables}
An {\bf assignment statement} creates new variables and gives them values.
\subsection{Variable names and keywords}
Variable names can be arbitrarily long. They can contain both letters
and numbers, but they have to begin with a letter. It is legal to use
uppercase letters, but it is a good idea to begin variable names with
a lowercase letter.

The interpreter uses {\bf keywords} to recognize the structure of the
program, and they cannot be used as variable names.

Python 2 has 31 keywords:
\begin{verbatim}
and       del       from      not       while
as        elif      global    or        with
assert    else      if        pass      yield
break     except    import    print
class     exec      in        raise
continue  finally   is        return
def       for       lambda    try
\end{verbatim}
\subsection{Operators and operands}
\subsection{Expressions and statements}
An {\bf expression} is a combination of values, variables, and operators. A
value all by itself is considered an expression, and so is a variable,
so the following are all legal expressions (assuming that the variable
\verb|x| has been assigned a value):
\begin{verbatim}
17
x
x + 17
\end{verbatim}

A {\bf statement} is a unit of code that the Python interpreter can execute.
We have seen two kinds of statement: print and assignment.

Technically an expression is also a statement, but it is probably
simpler to think of them as different things. The important difference
is that an expression has a value; a statement does not.
\subsection{Interactive mode and script mode}
\subsection{Order of operations}
\begin{itemize*}
    \item Parentheses
    \item Exponents
    \item Multiplication/Division
    \item Addition/Subtraction
\end{itemize*}
\subsection{String operations}
To perform a concatenation between two strings:
\begin{verbatim}
>>> a = 1
>>> print `list_' + str(a) + `.txt'
list_1.txt
>>> print `Spam'*3
SpamSpamSpam
\end{verbatim}
\subsection{Comments}
It is reasonable to assume that the reader can figure out
\emph{what} the code does; it is much more useful to explain
\emph{why}.

This comment is redundant with the code and useless:
\begin{verbatim}
v = 5     # assign 5 to v
\end{verbatim}
This comment contains useful information that is not in the code:
\begin{verbatim}
v = 5     # velocity in meters/second.
\end{verbatim}
Good variable names can reduce the need for comments, but long names
can make complex expressions hard to read, so there is a tradeoff.

\subsection{Debugging}

% Chapter 3
\section{Functions}
\subsection{Function calls}
In the context of programming, a \textbf{function} is a named
sequence of statements that performs a computation.
To define a function, specify the name and sequence of
statements. Then ``call'' the function by name later.
Example of a \textbf{function call}:
\begin{verbatim}
>>> type(32)
<type `int'>
\end{verbatim}
The name of the function is \verb|type|. The expression in
parentheses is called the \textbf{argument} of the function.
The result, for this function, is the type of the argument.

It is common to say that a function ``takes'' an argument and
``returns'' a result. The result is called the \textbf{return value}.
\subsection{Type conversion functions}
Python provides built-in functions that convert values from
one type to another. The \verb|int| function takes any value
and converts it to an integer:
\begin{verbatim}
>>> int(`32')
32
>>> int(3.999)
3
\end{verbatim}
Note that decimals are truncated, not rounded.

The \verb|float| function converts integers and strings to
floating-point numbers:
\begin{verbatim}
>>> float(32)
32.0
>>> float(`3.14159')
3.14159
\end{verbatim}
The \verb|str| function converts its argument to a string:
\begin{verbatim}
>>> str(32)
`32'
>>> str(3.14159)
`3.14159'
\end{verbatim}

% 3.3
\subsection{Math functions}
Python has a math module that provides most of the familiar
mathematical functions. A \textbf{module} is a file that
contains a collection of related functions. Modules must
be imported before they can be used
(such as \verb|>>> import math|, which creates a
\textbf{module object}) named math. If you print the module
object, you get some information about it:
\begin{verbatim}
>>> print math
<module `math' from `/usr/lib/python2.5/lib-dynload/math.so'>
\end{verbatim}
The module object contains the functions and variables defined
in the module. To access one of the functions, you have to specify
the name of the module and the name of the function, separated
by a dot (this format is called \textbf{dot notation}).
\begin{verbatim}
>>> ratio = signal_power / noise_power
>>> decibels = 10 * math.log10(ratio)

>>> radians = 0.7
>>> height = math.sin(radians)
\end{verbatim}
The first example computes the logarithm base 10 of the
signal-to-noise ratio. The math module also provides a function called
\verb|log| that computes logarithms base \verb|e|.

The second example finds the
sine of \verb|radians|.
Trigonometric functions (\verb|sin|, \verb|cos|, \verb|tan|, etc.)
\textcolor{red}{take arguments in radians.}

The expression \verb|math.pi| gets the variable \verb|pi| from
the math module, which is accurate to about 15 digits.

% 3.4
\subsection{Composition}
So far, we have looked at the elements of a program—variables,
expressions, and statements—in
isolation.
One of the most useful features of programming languages is their
ability to take small building
blocks and \textbf{compose} them. For example,
the argument of a function can be any kind of expression,
including arithmetic operators and function calls:
\begin{verbatim}
x = math.sin(degrees / 360.0 * 2 * math.pi)
x = math.exp(math.log(x+1))
\end{verbatim}

% 3.5
\subsection{Adding new functions}
A \textbf{Function definition} specifies the name of a new
function and the sequence of statements that execute when the
function is called, e.g.:
\begin{verbatim}
def do_nothing():
    print ``Doing nothing.''
\end{verbatim}

\verb|def| is a keyword that indicates that this is a function
definition. The name of the function is \verb|do_nothing|.
You should avoid having a variable and a function with the same
name. The empty parentheses indicate that this function doesn't
take any arguments.

The first line of the function definition is called the
\textbf{header}; the rest is called the \textbf{body}. The header
has to end with a colon and the body has to be indented.
By convention, the indentation is always four spaces
(see Section 3.13).

If you type a function definition in interactive mode, the interpreter
prints ellipses (\ldots) to let you
know that the definition isn't complete:
\begin{verbatim}
>>> def print_lyrics():
... print ``I'm a lumberjack, and I'm okay.''
... print ``I sleep all night and I work all day.''
...
\end{verbatim}
To end the function, enter an empty line (this is not
necessary in a script).

Defining a function creates a variable with the same name.
\begin{verbatim}
>>> print print_lyrics
<function print_lyrics at 0xb7e99e>
>>> type(print_lyrics)
<type `function'>
\end{verbatim}
The value of \verb|print_lyrics| is a \textbf{function object},
which has type \verb|`function'|.

The syntax for calling the new function is the same as for
built-in functions:
\begin{verbatim}
>>> print_lyrics()
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
\end{verbatim}
Once you have defined a function, you can use it inside another
function. For example, to repeat the previous refrain, we could write
a function called \verb|repeat_lyrics|:
\begin{verbatim}
def repeat_lyrics():
    print_lyrics()
    print_lyrics()
\end{verbatim}
And then call \verb|repeat_lyrics|:
\begin{verbatim}
>>> repeat_lyrics()
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
I'm a lumberjack, and I'm okay.
I sleep all night and I work all day.
\end{verbatim}

% 3.6
\subsection{Definitions and uses}
Pulling together the code fragments from the previous section, the
whole program looks like this:
\begin{verbatim}
def print_lyrics():
    print ``I'm a lumberjack, and I'm okay.''
    print ``I sleep all night and I work all day.''

def repeat_lyrics():
    print_lyrics()
    print_lyrics()

repeat_lyrics()
\end{verbatim}

This program contains two function definitions:
\verb|print_lyrics| and \verb|repeat_lyrics|. Function definitions
get executed just like other statements, but the effect is to create
function objects. The statements inside the function do not get executed
until the function is called, and the function definition generates no output.
As you might expect, you have to create a function before you can execute it.
In other words, the function definition has to be executed before the
first time it is called.

% 3.7
\subsection{Flow of execution}
In order to ensure that a function is defined before its first use,
you have to know the order in which statements are executed, which is
called the \textbf{flow of execution}.

Execution always begins at the first statement of the program.
Statements are executed one at a time, in order from top to bottom.

Function definitions do not alter the flow of execution of the
program, but remember that statements inside the function are not
executed until the function is called.

A function call is like a detour in the flow of execution. Instead of
going to the next statement, the flow jumps to the body of the
function, executes all the statements there, and then comes back to
pick up where it left off.

That sounds simple enough, until you remember that one function can
call another. While in the middle of one function, the program might
have to execute the statements in another function. But while
executing that new function, the program might have to execute yet
another function!

Fortunately, Python is good at keeping track of where it is, so each
time a function completes, the program picks up where it left off in
the function that called it. When it gets to the end of the program,
it terminates.

What’s the moral of this sordid tale? When you read a program, you
don’t always want to read from top to bottom. Sometimes it makes more
sense if you follow the flow of execution.

% 3.8
\subsection{Parameters and arguments}
Some of the built-in functions we have seen require arguments. For
example, when you call \verb|math.sin| you pass a number as an argument. Some
functions take more than one argument:
\verb|math.pow| takes two, the base and the exponent.

Inside the function, the arguments are assigned to variables called
\textbf{parameters}. Here is an example of a user-defined function that takes
an argument:
\begin{verbatim}
def print_twice(bruce):
    print bruce
    print bruce
\end{verbatim}
This function assigns the argument to a parameter named \verb|bruce|.
When the function is called, it prints the value of the parameter
(whatever it is) twice.

This function works with any value that can be printed.
\begin{verbatim}
>>> print_twice('Spam')
Spam
Spam
>>> print_twice(17)
17
17
>>> print_twice(math.pi)
3.14159265359
3.14159265359
\end{verbatim}
The same rules of composition that apply to built-in functions
also apply to user-defined functions, so we can use any kind
of expression as an argument for \verb|print_twice|:
\begin{verbatim}
>>> print_twice('Spam '*4)
Spam Spam Spam Spam
Spam Spam Spam Spam
>>> print_twice(math.cos(math.pi))
-1.0
-1.0
\end{verbatim}
The argument is evaluated before the function is called, so in
the examples the expressions \verb|`Spam '*4| and \verb|math.cos(math.pi)|
are only evaluated once.

You can also use a variable as an argument:
\begin{verbatim}
>>> michael = 'Eric, the half a bee.'
>>> print_twice(michael)
Eric, the half a bee.
Eric, the half a bee.
\end{verbatim}
The name of the variable we pass as an argument (\verb|michael|) has
nothing to do with the name of the parameter (\verb|bruce|). It
doesn’t matter what the value was called back home (in the
caller); here in \verb|print_twice|, we call everybody \verb|bruce|.

% 3.9
\subsection{Variables and parameters are local}
When you create a variable inside a function, it is \textbf{local},
which means that it only exists inside the function. For example:
\begin{verbatim}
def cat_twice(part1, part2):
    cat = part1 + part2
    print_twice(cat)
\end{verbatim}
This function takes two arguments, concatenates them, and
prints the result twice. Here is an example that uses it:
\begin{verbatim}
>>> line1 = 'Bing tiddle '
>>> line2 = 'tiddle bang.'
>>> cat_twice(line1, line2)
Bing tiddle tiddle bang.
Bing tiddle tiddle bang.
\end{verbatim}
When \verb|cat_twice| terminates, the variable \verb|cat| is destroyed.
If we try to print it, we get an exception:
\begin{verbatim}
>>> print cat
NameError: name 'cat' is not defined
\end{verbatim}
Parameters are also local. For example, outside \verb|print_twice|,
there is no such thing as \verb|bruce|.

% 3.10
\subsection{Stack diagrams}
Meh.

% 3.11
\subsection{Fruitful functions and void functions}
Some of the functions we are using, such as the math functions, yield
results; for lack of a better name, I call them
\textbf{fruitful functions}.
Other functions, like \verb|print_twice|, perform an action but don’t return
a value. They are called \textbf{void functions}.

When you call a fruitful function, you almost always want to do
something with the result; for example, you might assign it to a
variable or use it as part of an expression:
\begin{verbatim}
x = math.cos(radians)
golden = (math.sqrt(5) + 1) / 2
\end{verbatim}
When you call a function in interactive mode, Python displays the
result:
\begin{verbatim}
>>> math.sqrt(5)
2.2360679774997898
\end{verbatim}
But in a script, if you call a fruitful function all by itself, the
return value is lost forever.
\begin{verbatim}
math.sqrt(5)
\end{verbatim}
This script computes the square root of 5, but since it doesn’t store
or display the result, it is not very useful.

Void functions might display something on the screen or have some
other effect, but they don’t have a return value. If you try to assign
the result to a variable, you get a special value called \verb|None|.
\begin{verbatim}
>>> result = print_twice('Bing')
Bing
Bing
>>> print result
None
\end{verbatim}
The value \verb|None| is not the same as the string \verb|`None'|.
It is a special value that has its own type:
\begin{verbatim}
>>> print type(None)
<type 'NoneType'>
\end{verbatim}
The functions we have written so far are all void. We will start
writing fruitful functions in a few chapters.

% 3.12
\subsection{Why functions?}
It may not be clear why it is worth the trouble to divide a program
into functions. There are several reasons:
\begin{itemize*}
    \item Creating a new function gives you an opportunity to name a group of
        statements, which makes your program easier to read and debug.
    \item Functions can make a program smaller by eliminating repetitive code.
        Later, if you make a change, you only have to make it in one place.
    \item Dividing a long program into functions allows you to debug the parts
        one at a time and then assemble them into a working whole.
    \item Well-designed functions are often useful for many programs. Once you
        write and debug one, you can reuse it.
\end{itemize*}

% 3.13
\subsection{Importing with \texttt{from}}
Python provides two ways to import modules; we have already seen one:
\begin{verbatim}
>>> import math
>>> print math
<module 'math' (built-in)>
>>> print math.pi
3.14159265359
\end{verbatim}
If you import \verb|math|, you get a module object named \verb|math|.
The module object contains constants like \verb|pi| and functions like
\verb|sin| and \verb|exp|.

But if you try to access \verb|pi| directly, you get an error.
\begin{verbatim}
>>> print pi
Traceback (most recent call last):
  File ``<stdin>'', line 1, in <module>
NameError: name `pi' is not defined
\end{verbatim}
As an alternative, you can import an object from a module like this:
\begin{verbatim}
>>> from math import pi
\end{verbatim}
Now you can access pi directly, without dot notation.
\begin{verbatim}
>>> print pi
3.14159265359
\end{verbatim}
Or you can use the star operator to import \emph{everything} from the
module:
\begin{verbatim}
>>> from math import *
>>> cos(pi)
-1.0
\end{verbatim}
The advantage of importing everything from the math module is that
your code can be more concise. The disadvantage is that there might
be conflicts between names defined in different modules, or between
a name from a module and one of your variables.

% 3.14
\subsection{Debugging}
If you are using a text editor to write your scripts, you might run
into problems with spaces and tabs. The best way to avoid these
problems is to use spaces exclusively (no tabs). Most text editors
that know about Python do this by default, but some don’t.

Tabs and spaces are usually invisible, which makes them hard to debug,
so try to find an editor that manages indentation for you.

Also, don’t forget to save your program before you run it. Some
development environments do this automatically, but some don’t. In
that case the program you are looking at in the text editor is not the
same as the program you are running.

Debugging can take a long time if you keep running the same,
incorrect, program over and over!

Make sure that the code you are looking at is the code you are
running. If you’re not sure, put something like \verb|print 'hello'|
at the beginning of the program and run it again. If you don't see
\verb|hello|, you're not running the right program!


% Chapter 4
\section{Case study: interface design}
\section{Conditionals and recursion}
\section{Fruitful functions}
\section{Iteration}
\newpage%-------------------------------------------------------------------%
\section{Strings}
\subsection{A string is a sequence}
\subsection{\texttt{len}}
\subsection{Traversal with a \texttt{for} loop}
\subsection{String slices}
\subsection{Strings are immutable}
\subsection{Searching}
\subsection{Looping and counting}
\subsection{String methods}
A \textbf{method} is similar to a function - it takes arguments and returns a
value, but the syntax is different. For example, the method
\verb|upper|
takes a string and returns a new string with all uppercase letters:
\par Instead of the function syntax \verb|upper(word)|,
it uses the method syntax \verb|word.upper()|.
\begin{verbatim}
>>> word = 'banana'
>>> new_word = word.upper()
>>> print new_word
BANANA
\end{verbatim}
\par This form of dot notation specifies the name of the method,
\verb|upper|, and the name of the string to apply the method to,
\verb|word|. The empty
parentheses indicate that this method takes no argument.
\par A method call is called an \textbf{invocation};
in this case, we would say that
we are invoking \verb|upper| on the \verb|word|.
\par As it turns out, there is a string method named \verb|find| that is
remarkably similar to the function we wrote:
\begin{verbatim}
>>> word = `banana'
>>> index = word.find(`a')
>>> print index
1
\end{verbatim}
\par In this example, we invoke \verb|find| on \verb|word|
and pass the letter we are looking for as a parameter.
\par Actually, the \verb|find| method is more general than our function; it can
find substrings, not just characters:
\begin{verbatim}
>>> word.find('na')
2
\end{verbatim}
\par It can take as a second argument the index where it should start:
\begin{verbatim}
>>> word.find('na', 3)
4
\end{verbatim}
\par And as a third argument the index where it should stop:
\begin{verbatim}
>>> name = 'bob'
>>> name.find('b', 1, 2)
-1
\end{verbatim}
\par This search fails because \verb|b| does not appear in the index range from
\verb|1| to \verb|2| (not including \verb|2|).

\subsection{The \texttt{in} operator}
\subsection{String comparison}
\subsection{Debugging}

\newpage%-------------------------------------------------------------------%
\section{Case study: word play}
\section{Lists}
\subsection{A list is a sequence}
Like a string, a \textbf{list} is a sequence of values.
In a string, the values
are characters; in a list, they can be any type. The values in a list
are called \textbf{elements} or sometimes \textbf{items}.
\par There are several ways to create a new list; the simplest is to
enclose the elements in square brackets:
\begin{verbatim}
[10, 20, 30, 40]
['crunchy frog', 'ram bladder', 'lark vomit']
\end{verbatim}
\par \emph{The elements of a list don't have to be the same
type}. The following list contains a string, a float, an integer, and
(lo!) another list:
\begin{verbatim}
['spam', 2.0, 5, [10, 20]]
\end{verbatim}
\par A list within another list is \textbf{nested}.
\par A list that contains no elements is called an \emph{empty list};
you can create one with empty brackets, [].
\par As you might expect, you can assign list values to variables:
\begin{verbatim}
>>> cheeses = ['Cheddar', 'Edam', 'Gouda']
>>> numbers = [17, 123]
>>> empty = []
>>> print cheeses, numbers, empty
['Cheddar', 'Edam', 'Gouda'] [17, 123] []
\end{verbatim}
\subsection{Lists are mutable}
The syntax for \emph{accessing} the elements of a list is the same as for
accessing the characters of a string - the bracket operator. The
expression inside the brackets specifies the index. Remember that the
indices start at 0:
\begin{verbatim}
>>> print cheeses[0]
Cheddar
\end{verbatim}
\par \emph{Unlike strings}, lists are mutable. When the bracket operator appears
on the left side of an assignment, it identifies the element of the
list that will be assigned.
\begin{verbatim}
>>> numbers = [17, 123]
>>> numbers[1] = 5
>>> print numbers
[17, 5]
\end{verbatim}
\par The one-eth element of numbers, which used to be 123, is now 5.
\par You can think of a list as a relationship between indices and
elements. This relationship is called a \textbf{mapping}; each index
``maps to'' one of the elements.
\par List indices work the same way as string indices:
\begin{itemize*}
\item Any integer expression can be used as an index.
\item If you try to read or write an element that does not exist,
        you get an \verb|IndexError|.
\item If an index has a negative value, it counts backward from
    the end of the list.
\end{itemize*}
The \verb|in| operator also works on lists.
\begin{verbatim}
>>> cheeses = [`Cheddar', `Edam', `Gouda']
>>> `Edam' in cheeses
True
>>> `Brie' in cheeses
False
\end{verbatim}
\subsection{Traversing a list}
\par The most common way to traverse the elements of a list is with a
\verb|for| loop. The syntax is the same as for strings:
\begin{verbatim}
for cheese in cheeses:
    print cheese
\end{verbatim}
\par This works well if you only need to read the elements of the list. But if
you want to write or update the elements, you need the indices. A common
way to do that is to combine the functions \verb|range| and \verb|len|:
\begin{verbatim}
for i in range(len(numbers)):
    numbers[i] = numbers[i] * 2
\end{verbatim}
\par This loop traverses the list and updates each element.
\verb|len| returns the
number of elements in the list. \verb|range| returns a list of indices from 0
to $n-1$, where $n$ is the length of the list. Each time through the
loop \verb|i| gets the index of the next element. The assignment statement in
the body uses \verb|i| to read the old value of the element and to assign the
new value.
\par A for \verb|loop| over an \emph{empty} list never executes the body:
\begin{verbatim}
for x in []:
    print `This never happens.'
\end{verbatim}
\par Although a list can contain another list, \emph{the nested list still
counts as a single element}. The length of this list is 4:
\begin{verbatim}
[`spam', 1, [`Brie', `Roquefort', `Pol le Veq'], [1, 2, 3]]
\end{verbatim}
\subsection{List operations}
\textcolor{red}{IMPORTANT: these are not mathematical operations
for lists. Convert to numpy arrays:} \verb|a = np.array(a)|

The following doesn't work because x is a list, not an array.
\begin{verbatim}
>>> x = [1,2,3]
>>> y = x**2
\end{verbatim}

The \verb|+| operator concatenates lists:
\begin{verbatim}
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> c = a + b
>>> print c
[1, 2, 3, 4, 5, 6]
\end{verbatim}
\par Similarly, the \verb|*| operator repeats a list a given number of times:
\begin{verbatim}
>>> [0] * 4
[0, 0, 0, 0]
>>> [1, 2, 3] * 3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
\end{verbatim}
\par The first example repeats \verb|[0]| four times. The second example
repeats the list \verb|[1,2,3]| three times.
\subsection{List slices}
\subsection{List methods}
\subsection{Map, filter, and reduce}
\subsection{Deleting elements}
\subsection{Lists and strings}
\subsection{Objects and values}
\subsection{Aliasing}
\subsection{List arguments}
\subsection{Debugging}

\section{Dictionaries}

\section{Tuples}
\subsection{Tuples are immutable}
A tuple is a sequence of values. The values can be any type, and they are
indexed by integers, so in that respect tuples are a lot like lists.
\emph{The important difference is that tuples are immutable}.

Syntactically, a tuple is a comma-separated list of values:
\begin{verbatim}
>>> t = (`a', `b',`c',`d',`e')
\end{verbatim}
Parentheses are common, but not necessary.

To create a tuple with a single element, you have to include a final comma:
\begin{verbatim}
>>> t1 = `a',
>>> type(t1)
<type `tuple'>
\end{verbatim}
A value in parentheses is not a tuple:
\begin{verbatim}
>>> t2 = (`a')
>>> type(t2)
<type `str'>
\end{verbatim}
Another way to create a tuple is the built-in function \verb|tuple|.
With no argument, it creates an empty tuple:
\begin{verbatim}
>>> t = tuple()
>>> print t
()
\end{verbatim}
If the argument is a sequence (string, list or tuple), the result is a
tuple with the elements of the sequence:
\begin{verbatim}
>>> t = tuple('lupins')
>>> print t
('l', 'u', 'p', 'i', 'n', 's')
\end{verbatim}

Most list operators also work on tuples. The bracket operator indexes an
element:
\begin{verbatim}
>>> t = ('a', 'b', 'c', 'd', 'e')
>>> print t[0]
'a'
\end{verbatim}
And the slice operator selects a range of elements.
\begin{verbatim}
>>> print t[1:3]
('b', 'c')
\end{verbatim}
But if you try to modify one of the elements of the tuple, you get an error:
\begin{verbatim}
>>> t[0] = `A'
TypeError: object doesn't support item assignment
\end{verbatim}
You can’t modify the elements of a tuple, but you can \emph{replace}
one tuple with another:
\begin{verbatim}
>>> t = ('A',) + t[1:]
>>> print t
('A', 'b', 'c', 'd', 'e')
\end{verbatim}

\subsection{Tuple assignment}
It is often useful to swap the values of two variables. With conventional
assignments, you have to use a temporary variable.
For example, to swap \verb|a| and \verb|b|:
\begin{verbatim}
>>> temp = a
>>> a = b
>>> b = temp
\end{verbatim}
This solution is cumbersome; \textbf{tuple assignment} is more elegant:
\begin{verbatim}
>>> a, b = b, a
\end{verbatim}
The left side is a tuple of variables; the right side is a tuple of
expressions. Each value is assigned to its respective variable. All the
expressions on the right side are evaluated before any of the assignments.

The number of variables on the left and the number of values on the
right have to be the same:
\begin{verbatim}
>>> a, b = 1, 2, 3
ValueError: too many values to unpack
\end{verbatim}
More generally, the right side can be any kind of sequence (string,
list or tuple). For example, to split an email address into a user
name and a domain, you could write:
\begin{verbatim}
>>> addr = `monty@python.org'
>>> uname, domain = addr.split('\@')
\end{verbatim}
The return value from \verb|split| is a list with two elements;
the first element is assigned to \verb|uname|, the second to
\verb|domain|.
\begin{verbatim}
>>> print uname
monty
>>> print domain
python.org
\end{verbatim}

\subsection{Tuples as return values}
Strictly speaking, a function can only return one value, but if the
value is a tuple, the effect is the same as returning multiple values.
For example, if you want to divide two integers and compute the
quotient and remainder, it is inefficient to compute \verb|x/y|
and then \verb|x%y|.
It is better to compute them both at the same time.

The built-in function \verb|divmod| takes two arguments and returns a tuple
of two values, the quotient and remainder. You can store the result as
a tuple:
\begin{verbatim}
>>> t = divmod(7, 3)
>>> print t
(2, 1)
\end{verbatim}
Or use tuple assignment to store the elements separately:
\begin{verbatim}
>>> quot, rem = divmod(7, 3)
>>> print quot
2
>>> print rem
1
\end{verbatim}
Here is an example of a function that returns a tuple:
\begin{verbatim}
def min_max(t):
    return min(t), max(t)
\end{verbatim}
    max and min are built-in functions that find the largest and
    smallest elements of a sequence.
    \verb|min_max| computes both and returns
    a tuple of two values.

\subsection{Variable-length argument tuples}
Functions can take a variable number of arguments. A parameter name
that begins with * \textbf{gathers} arguments into a tuple. For example,
\verb|printall| takes any number of arguments and prints them:
\begin{verbatim}
def printall(*args):
    print args
\end{verbatim}
The gather parameter can have any name you like, but \verb|args| is
conventional. Here’s how the function works:
\begin{verbatim}
>>> printall(1, 2.0, '3')
(1, 2.0, '3')
\end{verbatim}
The complement of gather is \verb|scatter|. If you have a sequence of
values and you want to pass it to a function as multiple
arguments, you can use the * operator. For example,
\verb|divmod| takes
exactly two arguments; it doesn’t work with a tuple:
\begin{verbatim}
>>> t = (7, 3)
>>> divmod(t)
TypeError: divmod expected 2 arguments, got 1
\end{verbatim}
But if you scatter the tuple, it works:
\begin{verbatim}
>>> divmod(*t)
(2, 1)
\end{verbatim}

\subsection{Lists and tuples}
\verb|zip| is a built-in function that takes two or more sequences and
``zips'' them into a list of tuples where each tuple contains one element from
each sequence. In Python 3, \verb|zip| returns an iterator of tuples, but for
most purposes, an iterator behaves like a list.

This example zips a string and a list:
\begin{verbatim}
>>> s = 'abc'
>>> t = [0, 1, 2]
>>> zip(s, t)
[('a', 0), ('b', 1), ('c', 2)]
\end{verbatim}
The result is a list of tuples where each tuple contains a character
from the string and the corresponding element from the list.

If the sequences are not the same length, the result has the length of
the shorter one.

\begin{verbatim}
>>> zip('Anne', 'Elk')
[('A', 'E'), ('n', 'l'), ('n', 'k')]
\end{verbatim}
You can use tuple assignment in a \verb|for| loop to traverse a list of
tuples:
\begin{verbatim}
t = [('a', 0), ('b', 1), ('c', 2)]
for letter, number in t:
    print number, letter
\end{verbatim}
Each time through the loop, Python selects the next tuple in the
list and assigns the elements to \verb|letter| and \verb|number|.
The output of this loop is:
\begin{verbatim}
    0 a
    1 b
    2 c
\end{verbatim}
If you combine \verb|zip|, for and tuple assignment, you get a useful
idiom for traversing two (or more) sequences at the same time. For
example, \verb|has_match| takes two sequences, \verb|t1| and \verb|t2|,
and returns \verb|True| if there is an index \verb|i| such that
\verb|t1[i] == t2[i]|:
\begin{verbatim}
def has_match(t1, t2):
    for x, y in zip(t1, t2):
        if x == y:
            return True
    return False
\end{verbatim}
If you need to traverse the elements of a sequence and their indices, you
can use the built-in function \verb|enumerate|:
\begin{verbatim}
for index, element in enumerate(`abc'):
    print index, element
\end{verbatim}
The output of this loop is:
\begin{verbatim}
    0 a
    1 b
    2 c
\end{verbatim}
Again.

\subsection{Dictionaries and tuples}
Dictionaries have a method called \verb|items| that returns a list of tuples,
where each tuple is a key-value pair.
\begin{verbatim}
>>> d = {'a':0, 'b':1, 'c':2}
>>> t = d.items()
>>> print t
[('a', 0), ('c', 2), ('b', 1)]
\end{verbatim}
As you should expect from a dictionary, the items are in no particular
order. In Python 3, \verb|items| returns an iterator, but for many purposes,
iterators behave like lists.

Going in the other direction, you can use a list of tuples to
initialize a new dictionary:
\begin{verbatim}
>>> t = [('a', 0), ('c', 2), ('b', 1)]
>>> d = dict(t)
>>> print d
{'a': 0, 'c': 2, 'b': 1}
\end{verbatim}
Combining \verb|dict| with \verb|zip| yields a concise way to create a
dictionary:
\begin{verbatim}
>>> d = dict(zip('abc', range(3)))
>>> print d
{'a': 0, 'c': 2, 'b': 1}
\end{verbatim}
The dictionary method \verb|update| also takes a list of tuples and adds
them, as key-value pairs, to an existing dictionary.

Combining \verb|items|, tuple assignment and \verb|for|,
you get the idiom for traversing the keys and values of a dictionary:
\begin{verbatim}
for key, val in d.items():
    print val, key
\end{verbatim}
The output of this loop is:
\begin{verbatim}
    0 a
    2 c
    1 b
\end{verbatim}
Again.
It is common to use tuples as keys in dictionaries (primarily
because you can’t use lists). For example, a telephone directory
might map from last-name, first-name pairs to telephone numbers.
Assuming that we have defined \verb|last|, \verb|first| and
\verb|number|, we could write:
\begin{verbatim}
directory[last,first] = number
\end{verbatim}
The expression in brackets is a tuple. We could use tuple assignment
to traverse this dictionary.
\begin{verbatim}
for last, first in directory:
    print first, last, directory[last,first]
\end{verbatim}
This loop traverses the keys in \verb|directory|, which are tuples. It
assigns the elements of each tuple to \verb|last| and \verb|first|,
then prints the name and corresponding telephone number.
\subsection{Comparing tuples}
The relational operators work with tuples and other sequences; Python
starts by comparing the first element from each sequence. If they are
equal, it goes on to the next elements, and so on, until it finds
elements that differ. Subsequent elements are not considered (even if
they are really big).
\begin{verbatim}
>>> (0, 1, 2) < (0, 3, 4)
True
>>> (0, 1, 2000000) < (0, 3, 4)
True
\end{verbatim}
The \verb|sort| function works the same way. It sorts primarily by first
element, but in the case of a tie, it sorts by second element, and so
on.

This feature lends itself to a pattern called \textbf{DSU} for
\begin{description}
    \item [Decorate] a sequence by building a list of tuples with
        one or more sort keys preceding the elements from the
        sequence,
    \item [Sort] the list of tuples, and
    \item [Undecorate] by extracting the sorted elements of the
        sequence.
\end{description}
For example, suppose you have a list of words and you want to sort
them from longest to shortest:
\begin{verbatim}
def sort_by_length(words):
    t = []
    for word in words:
        t.append((len(word), word))

    t.sort(reverse=True)

    res = []
    for length, word in t:
        res.append(word)
    return res
\end{verbatim}
The first loop builds a list of tuples, where each tuple is a word
preceded by its length.

\verb|sort| compares the first element, length, first, and only considers the
second element to break ties. The keyword argument \verb|reverse=True| tells
\verb|sort| to go in decreasing order.

The second loop traverses the list of tuples and builds a list of
words in descending order of length.

\subsection{Sequences of sequences}
I have focused on lists of tuples, but almost all of the examples in
this chapter also work with lists of lists, tuples of tuples, and
tuples of lists. To avoid enumerating the possible combinations, it is
sometimes easier to talk about sequences of sequences.

In many contexts, the different kinds of sequences (strings, lists and
tuples) can be used interchangeably. So how and why do you choose one
over the others?

To start with the obvious, strings are more limited than other
sequences because the elements have to be characters. They are also
immutable. If you need the ability to change the characters in a
string (as opposed to creating a new string), you might want to use a
list of characters instead.

Lists are more common than tuples, mostly because they are mutable.
But there are a few cases where you might prefer tuples:
\begin{enumerate}
    \item In some contexts, like a \verb|return| statement,
        it is syntactically simpler to create a tuple than a list.
        In other contexts, you might prefer a list.
    \item If you want to use a sequence as a dictionary key, you have
        to use an immutable type like a tuple or string.
    \item If you are passing a sequence as an argument to a function,
        using tuples reduces the potential for unexpected behavior due
        to aliasing.
\end{enumerate}
Because tuples are immutable, they don’t provide methods like \verb|sort|
and \verb|reverse|, which modify existing lists. But Python provides the
built-in functions \verb|sorted| and \verb|reversed|, which take any
sequence as a parameter and return a new list with the same elements in
a different order.

\subsection{Debugging}
Lists, dictionaries and tuples are known generically as
\textbf{data structures}; in this chapter we are starting to see
compound data structures, like lists of tuples, and dictionaries that
contain tuples as keys and lists as values. Compound data structures are useful, but
they are prone to what I call \textbf{shape errors}; that is, errors caused
when a data structure has the wrong type, size or composition. For
example, if you are expecting a list with one integer and I give you a
plain old integer (not in a list), it won’t work.

To help debug these kinds of errors, I have written a module called
\verb|structshape| that provides a function, also called \verb|structshape|,
that takes any kind of data structure as an argument and returns a string
that summarizes its shape. You can download it from
\url{http://thinkpython.com/code/structshape.py}

Here’s the result for a simple list:
\begin{verbatim}
>>> from structshape import structshape
>>> t = [1,2,3]
>>> print structshape(t)
list of 3 int
\end{verbatim}
A fancier program might write ``list of 3 ints,'' but it was easier not
to deal with plurals. Here’s a list of lists:
\begin{verbatim}
>>> t2 = [[1,2], [3,4], [5,6]]
>>> print structshape(t2)
list of 3 list of 2 int
\end{verbatim}
If the elements of the list are not the same type, \verb|structshape| groups
them, in order, by type:
\begin{verbatim}
>>> t3 = [1, 2, 3, 4.0, '5', '6', [7], [8], 9]
>>> print structshape(t3)
list of (3 int, float, 2 str, 2 list of int, int)
\end{verbatim}
Here's a list of tuples:
\begin{verbatim}
>>> s = 'abc'
>>> lt = zip(t, s)
>>> print structshape(lt)
list of 3 tuple of (int, str)
\end{verbatim}
And here's a dictionary with 3 items that map integers to strings.
\begin{verbatim}
>>> d = dict(lt)
>>> print structshape(d)
dict of 3 int->str
\end{verbatim}
If you are having trouble keeping track of your data structures,
\verb|structshape| can help.



%----------------------------------------------------------------------%
% Chapter 13
\section{Case study: data structure selection}

%----------------------------------------------------------------------%
% Chapter 14 --- Done!
\section{Files}
\url{%
http://www.greenteapress.com/thinkpython/html/thinkpython015.html}
\subsection{Persistence}
Most of the programs we have seen so far are transient in the sense
that they run for a short time and produce some output, but when they
end, their data disappears. If you run the program again, it starts
with a clean slate.
\par Other programs are \textbf{persistent}: they run for a long time
(or all the time);
they keep at least some of their data in permanent storage (a
hard drive, for example); and if they shut down and restart, they pick
up where they left off.
\par Examples of persistent programs are operating systems, which run
pretty much whenever a computer is on, and web servers, which run all
the time, waiting for requests to come in on the network.
\par One of the simplest ways for programs to maintain their data is by
reading and writing text files. We have already seen programs that
read text files; in this chapter we will see programs that write them.
\par An alternative is to store the state of the program in a database. In
this chapter I will present a simple database and a module,
\verb|pickle|,
that makes it easy to store program data.

\subsection{Reading and writing}

\begin{verbatim}
file:
f=open(`file.txt',`[rwa]') [read,write,append]
s=f.readline()
f.close(),
alternatively:
for line in f:
  print line
\end{verbatim}
\par The \verb|write| method puts data into the file.
To write a file, you have to open it with mode `w' as a second parameter:

\begin{verbatim}
>>> fout = open(`output.txt', `w')
>>> print fout
    <open file `output.txt, mode `w' at 0x7fa44614c420>
>>> line1 = ``This here's the wattle,\n''
>>> fout.write(line1)
\end{verbatim}

\par \textcolor{red}{If the file already exists, opening it in
write mode clears out the
old data and starts fresh, so be careful!} If the file doesn't
exist, a new one is created.
The file object keeps track of where it is, so if you call
\verb|write| again, it adds the new data to the end.

\begin{verbatim}
>>> line2 = "the emblem of our land.\n"
>>> fout.write(line2)
\end{verbatim}

\par When you are done writing, you have to close the file.

\begin{verbatim}
>>> fout.close()
\end{verbatim}

\subsection{Format operator}

\begin{verbatim}
'''
Formatted output
 > print 'the number is {:.#e|:nd|:n.nf|:ns}'.format(x)
    exponential, integer, float, string
 General syntax:
'''
template.format(var_1,var_2,...var_n)
# template:
#'{[field][!conversion]:[spec]}'
field = index of variables listed in .format()
conversion = int, float, string, etc.
spec = specifier
[[fill]align][sign][#][0][minwidth][.prec][type]
align:
<(left,default)
>(right)
=(padding after sign, before digits)
^(center)
0: zero padding (same as '=' and fill char of 0)
type: e,f,g(general)

# Including text:
print 'Variable 2 is {1} and variable 1 is {0}'.format(var_1,var_2)

'{:8d}asdfad{:8.2f}'.format(i,f)
formats: {:nd},{:n.nf},{:ns}
#    n-number (width.precision), d-integer, f-float, s-string
#-------------- How to use a variable for width?? ------------------#
\end{verbatim}

The argument of \verb|write| has to be a string, so if we want to put other
values in a file, we have to convert them to strings. The easiest way
to do that is with \verb|str|:
\begin{verbatim}
>>> x = 52
>>> fout.write(str(x))
\end{verbatim}
An alternative is to use the \textbf{format operator}, \verb|%|.
When applied to integers, \verb|%| is the modulus operator.
But when the first operand is a string, \verb|%| is the format operator.
\par The first operand is the \textbf{format string},
which contains one or more
\textbf{format sequences}, which specify how the second operand is formatted.
The result is a string.
\par For example, the format sequence \verb|`%d'| means that the second operand
should be formatted as an integer (\verb|d| stands for ``decimal''):
\begin{verbatim}
>>> camels = 42
>>> '%d' % camels
'42'
\end{verbatim}
\par The result is the string \verb|`42'|,
which is not to be confused with the integer value 42.
\par A format sequence can appear anywhere in the string, so you can embed
a value in a sentence:
\begin{verbatim}
>>> camels = 42
>>> `I have spotted %d camels.' % camels
`I have spotted 42 camels.'
\end{verbatim}
\par If there is more than one format sequence in the string, the second
argument has to be a tuple. Each format sequence is matched with an
element of the tuple, in order.
\par The following example uses \verb|`%d'| to format an integer,
\verb|'%g'| to format a
floating-point number, and \verb|'%s'| to format a string:
\begin{verbatim}
>>> `In %d years I have spotted %g %s.' % (3, 0.1, `camels')
`In 3 years I have spotted 0.1 camels.'
\end{verbatim}
\par The number of elements in the tuple has to match the number of format
sequences in the string. Also, the types of the elements have to match
the format sequences:
\begin{verbatim}
>>> `%d %d %d' % (1, 2)
TypeError: not enough arguments for format string
>>> `%d' % `dollars'
TypeError: illegal argument type for built-in operation
\end{verbatim}
\par In the first example, there aren't enough elements; in the second,
the element is the wrong type.
\par The format operator is powerful, but it can be difficult to use. You
can read more about it at
\url{http://docs.python.org/2/library/stdtypes.html#string-formatting}.
\subsection{Filenames and paths} % 14.4
The \verb|os| (`operating system') module provides functions for working with
files and directories. \verb|os.getcwd| returns the current working directory.
\begin{verbatim}
>>> import os
>>> cwd = os.getcwd()
>>> print cwd
/home/dinsdale
\end{verbatim}
To find the absolute path to a \emph{file}:
\begin{verbatim}
>>> os.path.abspath('memo.txt')
'/home/dinsdale/memo.txt'
\end{verbatim}
\verb|os.path.exists| checks whether a file or directory exists.
\begin{verbatim}
>>> os.path.exists(`memo.txt')
True
\end{verbatim}

If it exists, \verb|os.path.isdir| checks whether it's a directory:
\begin{verbatim}
>>> os.path.isdir('memo.txt')
False
>>> os.path.isdir('music')
True
\end{verbatim}
Similarly, \verb|os.path.isfile| checks whether it's a file:

\verb|os.listdir| returns a list of the files (and other directories) in the given
directory:
\begin{verbatim}
>>> os.listdir(cwd)
['music', 'photos', 'memo.txt']
\end{verbatim}
To demonstrate these functions, the following example ``walks'' through a
directory, prints the names of all the files, and calls itself recursively on
all the directories.
\begin{verbatim}
def walk(dirname):
    for name in os.listdir(dirname):
        path = os.path.join(dirname, name)

        if os.path.isfile(path):
            print path
        else: walk(path)
\end{verbatim}
\verb|os.path.join| takes a directory and a file name and joins them into a
complete path.

\subsection{Catching exceptions} % 14.5

The \verb|try| statement:
\begin{verbatim}
try:
    fin = open('bad_file')
    for line in fin:
        print line
    fin.close()
except:
    print 'Something went wrong.'
\end{verbatim}
The syntax is similar to an \verb|if| statement.  Python starts by executing
the try clause. If all goes well, it skips the \verb|except| clause and
proceeds.  If an exception occurs, it jumps out of the \verb|try| clause and
executes the except clause.

Handling an exception with a try statement is called {\bf catching} an
exception. In this example, the \verb|except| clause prints an error message
that is not very helpful. In general, catching an exception gives you
a chance to fix the problem, or try again, or at least end the program
gracefully.

% 14.6
\subsection{Databases}
A {\bf database} is a file that is organized for storing data. Most
databases are organized like a dictionary in the sense that they map
from keys to values. The biggest difference is that the database is on
disk (or other permanent storage), so it persists after the program
ends.

The module \verb|anydbm| provides an interface for creating and
updating database files. As an example, I'll create a database that
contains captions for image files.

Opening a database is similar to opening other files:
\begin{verbatim}
>>> import anydbm
>>> db = anydbm.open(`captions.db', `c')
\end{verbatim}
The mode \verb|`c'| means that the database should be created if it
doesn't already exist. The result is a database object that can be
used (for most operations) like a dictionary. If you create a new
item, \verb|anydbm| updates the database file.
\begin{verbatim}
>>> db[`cleese.png'] = `Photo of John Cleese.'
\end{verbatim}
When you access one of the items, \verb|anydbm| reads the file:
\begin{verbatim}
>>> print db[`cleese.png']
Photo of John Cleese.
\end{verbatim}
If you make another assignment to an existing key, \verb|anydbm|
replaces the old value:
\begin{verbatim}
>>> db['cleese.png'] = 'Photo of John Cleese doing a silly walk.'
>>> print db['cleese.png']
Photo of John Cleese doing a silly walk.
\end{verbatim}
Many dictionary methods, like \verb|keys| and \verb|items|, also work
with database objects. So does iteration with a \verb|for| statement.
\begin{verbatim}
for key in db:
    print key
\end{verbatim}
As with other files, you should close the database when you are done:
\begin{verbatim}
>>> db.close()
\end{verbatim}

% 14.7
\subsection{Pickling}
A limitation of \verb|anydbm| is that the keys and values have to be
strings. The \verb|pickle| module translates almost any type of object
into a string suitable for storage in a database, and then translates
strings back into objects. \verb|pickle.dumps| takes an object as a
parameter and returns a string representation (\verb|dumps| is short
for ``dump string''):
\begin{verbatim}
>>> import pickle
>>> t = [1, 2, 3]
>>> pickle.dumps(t)
`(lp0\nI1\naI2\naI3\na.'
\end{verbatim}
\verb|pickle.loads| reconstitutes the object:
\begin{verbatim}
>>> t1 = [1, 2, 3]
>>> s = pickle.dumps(t1)
>>> t2 = pickle.loads(s)
>>> print t2
[1, 2, 3]
\end{verbatim}
Although the new object has the same value as the old, it is not (in
general) the same object:
\begin{verbatim}
>>> t1 == t2
True
>>> t1 is t2
False
\end{verbatim}
In other words, pickling and then unpickling has the same effect as
copying the object.

You can use \verb|pickle| to store non-strings in a database. In fact,
this combination is so common that it has been encapsulated in a
module called \verb|shelve|.

\textcolor{blue}{From my notes:}
\begin{verbatim}
pickle.dump(var_name, open(``save.p'', ``wb''))
var\_name = pickle.load(open(``save.p'', ``rb''))
\end{verbatim}

\subsection{Pipes} % 14.8
Any program that you can launch from the shell can also be launched
from Python using a {\bf pipe}. A pipe is an object that represents a
running program.

You can launch \verb|ls -l| with \verb|popen|:
\begin{verbatim}
>>> cmd = 'ls -l'
>>> fp = os.popen(cmd)
\end{verbatim}
The argument is a string that contains a shell command. The return
value is an object that behaves just like an open file. You can read
the output from the \verb|ls| process one line at a time with \verb|readline|
or get the whole thing at once with \verb|read|:
\begin{verbatim}
>>> res = fp.read()
\end{verbatim}
When you are done, you close the pipe like a file:
\begin{verbatim}
>>> stat = fp.close()
>>> print stat
None
\end{verbatim}
The return value is the final status of the \verb|ls| process;
None means that it ended normally (with no errors).

For example, most Unix systems provide a command called \verb|md5sum| that
reads the contents of a file and computes a ``checksum''. You
can read about MD5 at \url{http://en.wikipedia.org/wiki/Md5}. This command
provides an efficient way to check whether two files have the same
contents. The probability that different contents yield the same
checksum is very small (that is, unlikely to happen before the
universe collapses).

You can use a pipe to run \verb|md5sum| from Python and get the result:
\begin{verbatim}
>>> filename = `book.tex'
>>> cmd = `md5sum ' + filename
>>> fp = os.popen(cmd)
>>> res = fp.read()
>>> stat = fp.close()
>>> print res
1e0033f0ed0656636de0d75144ba32e0  book.tex
>>> print stat
None
\end{verbatim}

\subsection{Writing modules} % 14.9
Any file that contains Python code can be imported as a module. For
example, suppose you have a file named \verb|wc.py| with the following
code:
\begin{verbatim}
def linecount(filename):
    count = 0
    for line in open(filename):
        count += 1
    return count

print linecount('wc.py')
\end{verbatim}
You can import this program:
\begin{verbatim}
>>> import wc
7
\end{verbatim}
Now you have a module object \verb|wc| that provides a function called
\verb|linecount|:
\begin{verbatim}
>>> print wc
<module `wc' from `wc.py'>
>>> wc.linecount(`wc.py')
7
\end{verbatim}
The only problem with this example is that when you import the module
it executes the test code at the bottom. Normally when you import a
module, it defines new functions but it doesn't execute them.

Programs that will be imported as modules often use the following
idiom:
\begin{verbatim}
if __name__ == '__main__':
    print linecount('wc.py')
\end{verbatim}
\verb|__name__| is a built-in variable that is set when the program
starts. If the program is running as a script, \verb|__name__| has the
value \verb|__main__|; in that case, the test code is executed.
Otherwise, if the module is being imported, the test code is skipped.

\subsection{Debugging} % 14.10
When you are reading and writing files, you might run into problems
with whitespace. These errors can be hard to debug because spaces,
tabs, and newlines are normally invisible:
\begin{verbatim}
>>> s = `1 2\t 3\n 4'
>>> print s
1 2  3
 4
\end{verbatim}
The built-in function \verb|repr| takes any object as an argument and
returns a string representation of the object. For strings, it
represents whitespace characters with backslash sequences:
\begin{verbatim}
>>> print repr(s)
`1 2\t 3\n 4'
\end{verbatim}
This can be helpful for debugging.

One other problem you might run into is that different systems use
different characters to indicate the end of a line. Some systems use a
newline, represented \verb|\n|. Others use a return character, represented
\verb|\r|. Some use both. If you move files between different systems, these
inconsistencies might cause problems.

For most systems, there are applications to convert from one format to
another. You can find them (and read more about this issue) at
\url{http://en.wikipedia.org/wiki/Newline}. Or, of course, you could write
one yourself.


\newpage%--------------------------------------------------------------%
% Chapter 15
\section{Classes and objects}
\subsection{User-defined types}
We have used many of Python’s built-in types; now we are going to define a
new type. As an example, we will create a type called \verb|Point| that
represents a point in two-dimensional space.

In mathematical notation, points are often written as (x,y).
There are several ways we might represent points in Python:
\begin{itemize}
    \item We could store the coordinates separately in two variables, x and y.
    \item We could store the coordinates as elements in a list or tuple.
    \item We could create a new type to represent points as objects.
\end{itemize}
Creating a new type is (a little) more complicated than the other options,
but it has advantages that will be apparent soon.

A user-defined type is also called a {\bf class}.
A class definition looks like this:

\begin{verbatim}
class Point(object):
    """Represents a point in 2-D space."""
\end{verbatim}

This header indicates that the new class is a \verb|Point|, which is a
kind of \verb|object|, which is a built-in type.

The body is a docstring that explains what the class is for.
You can define variables and functions inside a class definition,
% See \S{}\ref{}.

Defining a class named \verb|Point| creates a class object.
\begin{verbatim}
>>> print Point
<class '__main__.Point'>
\end{verbatim}
Because \verb|Point| is defined at the top level, its ``full name'' is
\verb|__main__.Point|.

The class object is like a factory for creating objects. To create a
Point, you call \verb|Point| as if it were a function.
\begin{verbatim}
>>> blank = Point()
>>> print blank
<__main__.Point instance at 0xb7e9d3ac>
\end{verbatim}
The return value is a reference to a Point object, which we assign to
\verb|blank|. Creating a new object is called {\bf instantiation},
and the object is an
{\bf instance} of the class.

When you print an instance, Python tells you what
class it belongs to and where it is stored in memory (the prefix
\verb|0x| means that the following number is in hexadecimal).

\subsection{Attributes}
You can assign values to an instance using dot notation:
\begin{verbatim}
>>> blank.x = 3.0
>>> blank.y = 4.0
\end{verbatim}
This syntax is similar to the syntax for selecting a variable from a
module, such as \verb|math.pi| or \verb|string.whitespace|.
In this case, though, we are assigning values to named elements of
an object. These elements are called {\bf attributes}.
The variable \verb|blank| refers to a Point object, which contains
two attributes. Each attribute refers to a floating-point number.

You can read the value of an attribute using the same syntax:
\begin{verbatim}
>>> print blank.y
4.0
>>> x = blank.x
>>> print x
3.0
\end{verbatim}
The expression \verb|blank.x| means, ``Go to the object \verb|blank| refers
to and get the value of \verb|x|.'' In this case, we assign that value to a
variable named \verb|x|.  There is no conflict between the variable
\verb|x| and the attribute \verb|x|.

You can use dot notation as part of any expression. For example:
\begin{verbatim}
>>> print '(%g, %g)' % (blank.x, blank.y)
(3.0, 4.0)
>>> distance = math.sqrt(blank.x**2 + blank.y**2)
>>> print distance
5.0
\end{verbatim}
You can pass an instance as an argument in the usual way. For example:
\begin{verbatim}
def print_point(p):
    print '(%g, %g)' % (p.x, p.y)
\end{verbatim}
\verb|print_point| takes a point as an argument and displays it in
mathematical notation. To invoke it, you can pass \verb|blank| as an
argument:
\begin{verbatim}
>>> print_point(blank)
(3.0, 4.0)
\end{verbatim}
Inside the function, \verb|p| is an alias for \verb|blank|, so if the
function modifies \verb|p|, \verb|blank| changes.
\subsection{Rectangles}
Sometimes it is obvious what the attributes of an object should be, but
other times you have to make decisions. For example, imagine you are
designing a class to represent rectangles. What attributes would you use to
specify the location and size of a rectangle? You can ignore angle; to keep
things simple, assume that the rectangle is either vertical or horizontal.

There are at least two possibilities:
\begin{itemize}
    \item You could specify one corner of the rectangle (or the center),
        the width, and the height.
    \item You could specify two opposing corners.
\end{itemize}
At this point it is hard to say whether either is better than the other, so
we’ll implement the first one, just as an example.

Here is the class definition:
\begin{verbatim}
class Rectangle(object):
    """Represents a rectangle.

    attributes: width, height, corner.
    """
\end{verbatim}
The docstring lists the attributes: \verb|width| and \verb|height| are
numbers; \verb|corner| is a Point object that specifies the lower-left
corner.

To represent a rectangle, you have to instantiate a Rectangle object and
assign values to the attributes:
\begin{verbatim}
box = Rectangle()
box.width = 100.0
box.height = 200.0
box.corner = Point()
box.corner.x = 0.0
box.corner.y = 0.0
\end{verbatim}
The expression \verb|box.corner.x| means, ``Go to the object \verb|box|
refers to and select the attribute named \verb|corner|; then go to that
object and select the attribute named \verb|x|.''

An object that is an attribute of another object is {\bf embedded}.

\subsection{Instances as return values}
Functions can return instances. For example, \verb|find_center| takes a
\verb|Rectangle| as an argument and returns a \verb|Point| that contains
the coordinates of the center of the \verb|Rectangle|:
\begin{verbatim}
def find_center(rect):
    p = Point()
    p.x = rect.corner.x + rect.width/2.0
    p.y = rect.corner.y + rect.height/2.0
    return p
\end{verbatim}
Here is an example that passes \verb|box| as an argument as assigns the
resulting Point to \verb|center|:
\begin{verbatim}
>>> center = find_center(box)
>>> print_point(center)
(50.0, 100.0)
\end{verbatim}

\subsection{Objects are mutable}
You can change the state of an object by making an assignment to one of its
attributes. For example, to change the size of a rectangle without changing
its position, you can modify the values of \verb|width| and \verb|height|:
\begin{verbatim}
box.width = box.width + 50
box.height = box.width + 100
\end{verbatim}
You can also write functions that modify objects. For example,
\verb|grow_rectangle| takes a Rectangle object and two numbers,
\verb|dwidth| and \verb|dheight|, and adds the numbers to the width and
height of the rectangle:
\begin{verbatim}
def grow_rectangle(rect, dwidth, dheight):
    rect.width += dwidth
    rect.height += dheight
\end{verbatim}
Here is an example that demonstrates the effect:
\begin{verbatim}
>>> print box.width
100.0
>>> print box.height
200.0
>>> grow_rectangle(box, 50, 100)
>>> print box.width
150.0
>>> print box.height
300.0
\end{verbatim}
Inside the function, \verb|rect| is an alias for \verb|box|, so if the
function modfies \verb|rect|, \verb|box| changes.

\subsection{Copying}
Aliasing can make a program difficult to read because changes in one place
might have unexpected effects in another place. It is hard to keep track of
all the variables that might refer to a given object.

Copying an object is often an alternative to aliasing. The \verb|copy|
module contains a function called \verb|copy| that can duplicate any
object:
\begin{verbatim}
>>> p1 = Point()
>>> p1.x = 3.0
>>> p1.y = 4.0

>>> import copy
>>> p2 = copy.copy(p1)
\end{verbatim}
\verb|p1| and \verb|p2| contain the same data, but they are not the same
Point.
\begin{verbatim}
>>> print_point(p1)
(3.0, 4.0)
>>> print_point(p2)
(3.0, 4.0)
>>> p1 is p2
False
>>> p1 == p2
False
\end{verbatim}
The \verb|is| operator indicates that \verb|p1| and \verb|p2| are not the
same object, which is what we expected. But you might have expected
\verb|==| to yield \verb|True| because these points contain the same data.
In that case, you will be disappointed to learn that for instances, the
default behavior of the \verb|==| operator is the same as the \verb|is|
operator; it checks object identity, not object equivalence.  This behavior
can be changed—we’ll see how later.  If you use \verb|copy.copy| to
duplicate a Rectangle, you will find that it copies the Rectangle object
but not the embedded Point.
\begin{verbatim}
>>> box2 = copy.copy(box)
>>> box2 is box
False
>>> box2.corner is box.corner
True
\end{verbatim}
This operation is called a {\bf shallow copy} because it copies the object
and any references it contains, but not the embedded objects.

For most applications, this is not what you want. In this example, invoking
\verb|grow_rectangle| on one of the Rectangles would not affect the other,
but invoking \verb|move_rectangle| on either would affect both! This
behavior is confusing and error-prone.

Fortunately, the \verb|copy| module contains a method named \verb|deepcopy| that copies
not only the object but also the objects it refers to, and the objects
\emph{they}
refer to, and so on. You will not be surprised to learn that this operation
is called a {\bf deep copy}.
\begin{verbatim}
>>> box3 = copy.deepcopy(box)
>>> box3 is box
False
>>> box3.corner is box.corner
False
\end{verbatim}
\verb|box3| and \verb|box| are completely separate objects.

\subsection{Debugging}
When you start working with objects, you are likely to encounter some new
exceptions. If you try to access an attribute that doesn’t exist, you get
an \verb|AttributeError|:
\begin{verbatim}
>>> p = Point()
>>> print p.z
AttributeError: Point instance has no attribute 'z'
\end{verbatim}
If you are not sure what type an object is, you can ask:
\begin{verbatim}
>>> type(p)
<type '__main__.Point'>
\end{verbatim}
If you are not sure whether an object has a particular attribute, you can
use the built-in function \verb|hasattr|:
\begin{verbatim}
>>> hasattr(p, 'x')
True
>>> hasattr(p, 'z')
False
\end{verbatim}
The first argument can be any object; the second argument is a
\emph{string} that contains the name of the attribute.
\newpage%--------------------------------------------------------------%
% Chapter 16
\section{Classes and functions}
\newpage%--------------------------------------------------------------%
% Chapter 17
\section{Classes and methods}
\newpage%--------------------------------------------------------------%
% Chapter 18
\section{Inheritance}
\newpage%--------------------------------------------------------------%
% Chapter 19
\section{Case study: Tkinter}
\newpage%--------------------------------------------------------------%
% Chapter 20
\section{Debugging}
\newpage%--------------------------------------------------------------%
% Chapter 21
\section{Analysis of Algorithms}
\newpage%--------------------------------------------------------------%
% Chapter 22
\section{Lumpy}

\section*{Glossary}
\addcontentsline{toc}{section}{Glossary}
\begin{description}
\item [accumulator] A variable used in a loop to add up or accumulate a result.
\item [aliasing] A circumstance where two or more variables refer to the same object.
\item [argument] A value provided to a function when the function is
    called. This value is assigned to the corresponding parameter in
    the function.

\item [augmented assignment] A statement that updates the value of a variable using an operator like +=.
\item [body] The sequence of statements inside a function definition.
\item [composition] Using an expression as part of a larger
    expression, or a statement as part of a larger statement.
\item [data structure] A collection of related values, often organized
    in lists, dictionaries, tuples, etc.
\item [delimiter] A character or string used to indicate where a string should be split.
\item [dot notation] The syntax for calling a function in another
    module by specifying the module name followed by a dot (period)
    and the function name.
\item [DSU] Abbreviation of ``decorate-sort-undecorate,'' a pattern that
    involves building a list of tuples, sorting, and extracting part
    of the result.
\item [element] One of the values in a list (or other sequence), also called items.
\item [equivalent] Having the same value.
\item [filter] A processing pattern that traverses a list and selects the elements that satisfy some criterion.
\item [flow of execution] The order in which statements are executed
    during a program run.
\item [frame] A box in a stack diagram that represents a function
    call. It contains the local variables and parameters of the
    function.
\item [fruitful function] A function that returns a value.
\item [function] A named sequence of statements that performs some
    useful operation. Functions may or may not take arguments and may
    or may not produce a result.
\item [function call] A statement that executes a function. It
    consists of the function name followed by an argument list.
\item [function definition] A statement that creates a new function,
    specifying its name, parameters, and the statements it executes.
\item [function object] A value created by a function definition. The
    name of the function is a variable that refers to a function
    object.
\item [gather] The operation of assembling a variable-length argument
    tuple.
\item [header] The first line of a function definition.
\item [identical] Being the same object (which implies equivalence).
\item [import statement] A statement that reads a module file and
    creates a module object.
\item [index] An integer value that indicates an element in a list.
\item [list] A sequence of values.
\item [list traversal] The sequential accessing of each element in a list.
\item [local variable] A variable defined inside a function. A local
    variable can only be used inside its function.
\item [map] A processing pattern that traverses a sequence and performs an operation on each element.
\item [mapping] A relationship in which each element of one set corresponds to an element of another set. For example, a list is a mapping from indices to elements.
\item [module] A file that contains a collection of related functions
    and other definitions.
\item [module object] A value created by an \verb|import| statement
    that provides access to the values defined in a module.
\item [nested list] A list that is an element of another list.
\item [object] Something a variable can refer to. An object has a type and a value.
\item [parameter] A name used inside a function to refer to the value
    passed as an argument.
\item [reduce] A processing pattern that traverses a sequence and accumulates the elements into a single result.
\item [reference] The association between a variable and its value.
\item [return value] The result of a function. If a function call is
    used as an expression, the return value is the value of the
    expression.
\item [scatter] The operation of treating a sequence as a list of
    arguments.
\item [shape (of a data structure)] A summary of the type, size and
    composition of a data structure.
\item [stack diagram] A graphical representation of a stack of
    functions, their variables, and the values they refer to.
\item [traceback] A list of the functions that are executing, printed
    when an exception occurs.
\item [tuple] An immutable sequence of elements.
\item [tuple assignment] An assignment with a sequence on the right
    side and a tuple of variables on the left. The right side is
    evaluated and then its elements are assigned to the variables on
    the left.
\item [void function] A function that doesn't return a value.
\end{description}

\newpage\section{Quick reference}
Resources: astropy.org, rgex

\begin{verbatim}
export PYTHONPATH="${PYTHONPATH}:/new/path"
\end{verbatim}
not compiled, execute with \verb|cl> python program_name.py|
or \verb|cl> ./program_name.py| IF you have the top line in your program
(must be the first line, literally). \textcolor{red}{Including the
\# sign?}

\begin{verbatim}
import sys
sys.path
\end{verbatim}

\subsection{Debugging}
\begin{verbatim}
import pdb
pdb.set_trace() #equivalent of 'STOP' in IDL
cl> python code.py
...
(Pdb) continue
\end{verbatim}
Type `continue' at the end to keep going. Type `q' to quit.
Can also print variables, types, etc.\ in this mode.

\subsection{Strings}

\begin{verbatim}
>>> s1 = "/home/users/laurel/"
>>> s2 = "file.dat"
>>> s1 + s2
  "/home/users/laurel/file.dat"
>>> s2[0:5]
  'file.'
>>> s2[:5]
  'file.'
>>> s2[-5:]
  'e.dat'
>>> len(s2)
  8
\end{verbatim}

\subsection{Maths}
\url{http://docs.scipy.org/doc/numpy/reference/routines.math.html}

\begin{verbatim}
# operators (add, subtract, multiply, divide, exponent)
+,-,*,/,**,+=,-=,*=,/=,++,--
bitwise operators (and, or, xor, not):
&,|,^,!
# string operators
+, str[i1:i2] (string slice, but string is immutable)
\end{verbatim}

\begin{verbatim}
import math
math.sqrt(x)
math.pow(x,y)   # x^y
math.log(x)
math.log10(x)
math.exp(x)
math.fabs(x)    # absolute value of x
math.acos(x)    # arccosine in radians
  cos, sin, tan, atan, asin
math.radians(x) # converts from degrees to radians
math.degrees(x) # converts from radians to degrees
\end{verbatim}

Interpolation:
\begin{verbatim}
from scipy.interpolate import interp1d
  # interp1d(x, y, 'cubic')
  # x is data, y = f(x)
from scipy.interpolate import interp2d
  # interp2d(x, y, z, 'cubic')
  # x and y are data, z = f(x,y)
\end{verbatim}

\subsection{Lists}
\begin{verbatim}
x = [0,1,2,3,4]
x = range(5) # Same as above
x.append(newValue)

>>> A = [1,2,3]
  [1,2,3]
>>> A*2
  [1,2,3,1,2,3]
\end{verbatim}

\subsection{numpy arrays}
Compare to list example above:
\begin{verbatim}
>>> B = np.array([1,2,3])
  [1 2 3]
>>> B*2
  [2 4 6]

import numpy as np
np.zeros(n,m)
np.array(n) # creates an array that consists of n, NOT LENGTH n
np.array([[a,b,c,d][e,f,g]])
np.arange(n) # [0,1,2,...,n-1]
np.arange([start,] stop, [step,] dtype=None)
np.ndarray(...) # two-dimensional array
np.argmax(x) # returns INDEX of max value of x array
np.append(array,what_to_append)
np.linspace(0,9,100) #0-9 with 100 increments
np.logspace
np.sum(array)
np.roll(x,2) # (~IDL's SHIFT); shifts array elements 2 to the right
  --> [3,4,0,1,2] # note x is still the same, unless do x = np.roll(...)
np.where(condition) --> array
np.max/min(array)
np.median(A, axis=#)
    axis - along which median is computed. Get array back, or if no
    axis is specified, get a single number back.

    A = [[1 2 3]
         [4 5 6]
         [7 8 9]]

    np.median(A) --> 5.0
    np.median(A, axis=0) --> [4 5 6]
    np.median(A, axis=1) --> [2 5 8]
    np.median(A, axis=2) --> Error

a.min(axis=0)
a.max(axis=1)
a.std()     # standard deviation
a.var()     # Normalized with N (not N-1)
a.sum()
\end{verbatim}

\verb|array.mean()| vs.\ \verb|np.mean(array)| \ldots?

\begin{verbatim}
>>> a = np.array(6)
  array([0,1,2,3,4,5])
>>> a = a.reshape(2,3)
  array([[0,1,2],
         [3,4,5]])
>>> a.shape
  (2,3)
>>> a.ndim
  2
>>> a.size
  6


np.log
np.log10


>>>>>>> e65b08cb7892365af863d0202be5fe03115aa38c

>>> A = np.array([1,2,3])
>>> A + 1
    [2,3,4]

str(number) --> num to string
abs(number) --> abslute value
int(number) --> float to integer

num_elements = len(Array)

# dynamic memory allocation

# structures
(dictionaries, see also lists)
var={'name':'test', ra:1.}
print var['name'], var['test']
dicname = { 'A':[1,2,3], 'B':[2,4,6], 'C':[3,9,15] }
print dicname
# dictionaries are indexed by keys, rather than numbers.
# Keys can be any immutable type. Can't use lists, since they can be modified.
profile = {'density':rho_r, 'mass':mass, ...}
density = np.array(profile['density'])

# structure arrays
sarray = np.zeros(nelem,
 dtype=[('name','a12'),('ra','f4'),('dec','f4')])
sarray=np.zeros(nelem,
 dtype={'names': ('name', 'ra', 'dec'),
  'formats': ('S12','f4','f4')})
\end{verbatim}


\subsection{logical operators}
\begin{verbatim}
==, !=, >, >=, <, <=, and, or, not
\end{verbatim}

\subsection{conditionals}
\begin{verbatim}
if (condition):
    statements
elif (condition):
    statements
else:
    statements
    pass # need to have 'something' here. ???
if (condition):
    break
else:
    continue
\end{verbatim}


\subsection{Looping}
\textcolor{red}{PYTHON IS NOT INCLUSIVE!}

Basic syntax (by default, start = 0 and step = 1)
\begin{verbatim}
for i in range([start,]stop[, step])

for i in (list):
for i in range(0, 10, 0.1)
for i in range(len(list)):

>>> root = "output."
>>> for i in range(1,101):
    ... outfile = root + repr(i).zfill(3) + '.txt'
    ... print outfile

output.001.txt
...
output.100.txt
\end{verbatim}
repr(i) returns a string and zfill(3) pads with leading zeros.

\begin{verbatim}

while (condition):
    statements

\end{verbatim}

\subsection{I/O}
Simple output:
\begin{verbatim}
print 'characters', string, variable
\end{verbatim}

Simple reading from terminal and file:
\begin{verbatim}
terminal:
s = raw_input('prompt')
\end{verbatim}

Higher level file reading routines:
\begin{verbatim}
data = numpy.loadtxt(file,
dtype=[('name','a12'),('ra',f4),('dec','f4')])
data = astropy.io.ascii(file)
\end{verbatim}


\subsection{FITS files}
\begin{verbatim}%-------------
import glob
fls = glob.glob(`*.fits')  # list of filenames

from astropy.io import fits
hdu = fits.open(`name.fits')  # Create list object.
hdu.info()
info = hdu[0].header
image = hdu[0].data  # type(image) --> numpy.ndarray
image.shape  # shape (dimensions) of numpy.ndarray
hdu.close()  # Always do this
\end{verbatim}%---------------

\subsection{Classes (maybe)}
\begin{verbatim}
# To allow import:
def main():
    # program statements
    print "hello world."
if __name__=="__main__":  # flexible way of running routines
    main()
\end{verbatim}

\subsection{Plotting}
\url{http://latexcolor.com/}
\url{http://matplotlib.org/api/axes_api.html}

\verb|ax.streamplot()| Draw streamlines of a vector flow!

\begin{verbatim}
import matplotlib.pyplot as plt
fig = plt.figure()
fig.set_size_inches(width, height)
fig.suptitle(
    'bold figure suptitle',
    fontsize = 14, fontweight='bold'
    )
plt.xlabel('labelname',fontsize=14,color='red'
    color='#eeefff') # Color???
plt.xlabel('xlabel')

plt.tight_layout()
plt.axis('tight')
  # difference?

plt.colorbar()
\end{verbatim}

Individual axes:
\begin{verbatim}
ax.set_xlabel(`labelname',
    fontsize = 14,
    )
ax.set_xticklabels(
    columnlabels,  # ?
    rotation=(45),
    fontsize=10,
    va=`bottom', ha=`left',
    )
ax.set_xticks(
    np.arange(start,stop,step)
    )
ax.tick_params(  # things that apply to x and y?
    axis=['x'|'y'|'both'],
    labelsize='large'  # dif. bet. this and ax.set_xticklabel?
    )
ax.set_yscale('log')
ax.axis('tight')
\end{verbatim}

Loop to get indefinite number of plots in one figure:
\begin{verbatim}
for i in range(0,some_number):
    ax = fig.add_subplot(n,m,i+1)
    # n - vertical; m - horizontal; i+1 - plot being defined as 'ax'
\end{verbatim}

Put two plots on the same axes:
\begin{verbatim}
ax1.plot(x, y1, 'r')
ax2 = ax1.twinx()
ax2.plot(x, y2, 'g')
for tl in ax2.get_yticklabels():
    tl.set_color('g')
ax.tick_params(labelsize = "small") # size of numbers on each tick mark,
                                        not axis titles
savefig('fig.png', bbox_inches = 'tight')
\end{verbatim}
x and y limits: order matters! Put after set x ticks.

No idea what this stuff is doing:
\begin{verbatim}
------
set_data_interval()
subplots_adjust
set_ylim(min, max)
fig, ax = plt.subplots()  # Simpler?

plt.figure(figsize = (20, 10))
fig, ax = plt.subplots(figsize=(20, 10))
plt.savefig("im.png", bbox_inches = 'tight', dpi = 100)
------
\end{verbatim}

\subsubsection{Imaging}
\begin{verbatim}
ax.imshow(hdu.data, cmap='gray')
cube = np.array([im1, im2, im3])
np.power(image, 0.1)
\end{verbatim}
Use same axis options as plotting to set tick marks, etc.

\subsubsection{Legend}
\begin{minipage}{0.45\textwidth}
\begin{verbatim}
ax.plot(x,y1, `k--', label=`line 1')
ax.plot(x,y2, `k:', label=`line 2')
ax.plot(x,y3, `k', label=`line 3')
legend = ax.legend(loc=`upper center',
                      = `lower left',
               shadow = True)
\end{verbatim}
\end{minipage}%
\begin{minipage}[t]{0.45\textwidth}
    \vspace{0pt}

    \par `k' is black.
\end{minipage}

\subsubsection{Save figures}
\begin{verbatim}
pyplot.show()
pyplot.savefig('tmp.pdf') # rewritten each time!
\end{verbatim}

\end{document}
